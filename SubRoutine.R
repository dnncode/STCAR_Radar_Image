#******************************************************
#******************************************************
# Sub-routines for "new_QPF_IBM_v1.R":
# 1. TREC function (disabled; see "TREC_function.R", "TREC_function_P1.R", "TREC_function_P2.R"
# 2. Smooth Scan: spatial smooth a radar scan
# 3. grd to grd.full expansion: grid conversion
#******************************************************
#******************************************************


#******************************************************
#******************************************************
# Code information (available on Github: )
# Author1: Xiao Liu (IBM Thomas J. Watson Research Center) 
# Author2: Vikneswaran Gopal (Department of Statistics and Applied Probability, National University of Singapore)
#******************************************************
#******************************************************

#******************************************************
#******************************************************
# Contact information: Xiao Liu, liuxiao314923@gmail.com
#******************************************************
#******************************************************



if (FALSE){
###########################################################
# TREC function (START)
###########################################################

TREC <- function(data, data2, grd.p, n.TREC.ctr, box.id, grd.TREC, PLOT){

# data: data.frame radar scan
# data2: data.frame radar scan 2
# grd.p: grid point
# n.TREC.ctr: number of TREC boxes

# ----------
SVY21 <- '+proj=tmerc +lat_0=1.366666666666667 +lon_0=103.8333333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0'
colPalette <- adjustcolor(colorRampPalette(brewer.pal(n=9, 'YlOrRd'))(100), .85)
at.points <- seq(from=-35, to=75, length=33)
# ----------

#data <- (scan[[i.scan]]$data)@data
#data2 <- (scan[[i.scan+5]]$data)@data

Cross_R <- array(0/0,dim=c(n.TREC.ctr,1))
box_select <- array(0/0,dim=c(n.TREC.ctr,1))
for (i in 1:n.TREC.ctr){
	
	temp1 <- data[box.id[,i],1]
	search.R <- 10000 # search radius
	center.select <- grd.TREC[i]
	dist <- sqrt(  (coordinates(center.select)[,1]-coordinates(grd.TREC)[,1])^2 + (coordinates(center.select)[,2]-coordinates(grd.TREC)[,2])^2  )	
	case <- which(dist < search.R )

	temp3 <- array(0/0,dim=c(length(case),1))
	for (j in 1:length(case)){
	temp2 <- data2[box.id[,case[j]],1]
	temp3[j,1] <- ( sum(temp1*temp2) - sum(temp1)*sum(temp2)/19/19 ) / (sum(temp1^2) - 19*19*mean(temp1)^2) / (sum(temp2^2) - 19*19*mean(temp2)^2)
	}

if (sum(!is.na(temp3))==0){
Cross_R[i,1] <- 0/0
box_select[i,1] <- 0/0
}else{
Cross_R[i,1] <- max(temp3,na.rm=TRUE)
box_select[i,1] <- case[which(temp3==Cross_R[i,1])][1]
}
print(i)	

}


if (PLOT) {
data.spdf <- SpatialPixelsDataFrame(grd.p,data.frame(data),proj4string=CRS(SVY21))
plot(sgBd,axes=TRUE,xlim=c(bbox(grd.p)[1,1],bbox(grd.p)[1,2]),ylim=c(bbox(grd.p)[2,1],bbox(grd.p)[2,2]),col="blue")
image(data.spdf,add=TRUE,col=colPalette,zlim=c(at.points[1],at.points[length(at.points)]))
arrows(coordinates(grd.TREC)[,1],coordinates(grd.TREC)[,2],
		coordinates(grd.TREC)[box_select,1],
		coordinates(grd.TREC)[box_select,2],length=0.05,col="blue",lwd=1)
}

return(box_select)

} # function TREC

###########################################################
# TREC function (END)
###########################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
}

###########################################################
# Smooth Scan (START)
###########################################################
SmoothScan <- function(data, grd.p, PLOT, Theta) {
library(fields)

# ----------
SVY21 <- '+proj=tmerc +lat_0=1.366666666666667 +lon_0=103.8333333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0'
colPalette <- adjustcolor(colorRampPalette(brewer.pal(n=9, 'YlOrRd'))(100), .85)
at.points <- seq(from=-35, to=75, length=33)
# ----------

n.grd <- length(grd.p)

test <- as.matrix(data) # convert data into a vector
test.1 <- matrix(test, nrow=sqrt(n.grd), ncol=sqrt(n.grd))  # convert data into row-col matrix
test.2 <- image.smooth(test.1, wght = NULL, dx = 1, dy = 1,
theta = Theta, grid = NULL, tol = 1e-08, xwidth = NULL, ywidth = NULL,
weights = NULL)  # smooth the data
test.3 <- matrix(test.2$z,nrow=length(test.2$z),ncol=1) # convert data back to vector
data.smooth.spdf <- SpatialPixelsDataFrame(grd.p,data.frame(test.3),proj4string=CRS(SVY21)) # SPDF format

if (PLOT) {
plot(sgBd,axes=TRUE,xlim=c(bbox(grd.p)[1,1],bbox(grd.p)[1,2]),
		ylim=c(bbox(grd.p)[2,1],bbox(grd.p)[2,2]),col="blue")
#plot(grd,add=TRUE)
image(data.smooth.spdf,add=TRUE,col=colPalette,zlim=c(at.points[1],at.points[length(at.points)]))
}

test.3 <- data.frame(test.3)

return(test.3)

}
###########################################################
# Smooth Scan (END)
###########################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################





# grd to grd.full expansion

###########################################################
# GtoFull function (START)
###########################################################
GtoFull <- function(grd,grd.full,data) {

#grd.full: 480 by 480
#grd: 48 by 48

dim.grd.full <- sqrt(length(grd.full))
dim.grd <- sqrt(length(grd))


n <- sqrt(length(grd.full)/length(grd))
data.output <- array(0/0,dim=c(length(grd.full),1))
for (i in 1:length(grd)){

	row.i <- floor( (i-0.01)/48) + 1
	select <- c( (((row.i-1)*10+1-1)*480+1): (((row.i-1)*10+1-1)*480+10) )
	for (j in 2:n){
		temp <- c( (((row.i-1)*10+1-1)*480+1): (((row.i-1)*10+1-1)*480+10) + 480*(j-1)  ) 
		select <- c(select,temp)
	}	
	col.j <- i - (row.i-1) * 48
	select <- select + (col.j-1)*10

	data.output[select,1] <- data[i]

} # for i
return(data.output)

} # function


###########################################################
# GtoFull (END)
###########################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################
##########################################################################################################################

